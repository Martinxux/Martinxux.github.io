<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021华语辩坛老友赛决赛--熬夜是现代人的病/药</title>
    <link href="/2024/08/03/2021%E5%8D%8E%E8%AF%AD%E8%BE%A9%E5%9D%9B%E8%80%81%E5%8F%8B%E8%B5%9B%E5%86%B3%E8%B5%9B-%E7%86%AC%E5%A4%9C%E6%98%AF%E7%8E%B0%E4%BB%A3%E4%BA%BA%E7%9A%84%E7%97%85-%E8%8D%AF/"/>
    <url>/2024/08/03/2021%E5%8D%8E%E8%AF%AD%E8%BE%A9%E5%9D%9B%E8%80%81%E5%8F%8B%E8%B5%9B%E5%86%B3%E8%B5%9B-%E7%86%AC%E5%A4%9C%E6%98%AF%E7%8E%B0%E4%BB%A3%E4%BA%BA%E7%9A%84%E7%97%85-%E8%8D%AF/</url>
    
    <content type="html"><![CDATA[<p>人为什么要喝酒？</p><p>因为不喝酒的时候不快乐</p><p>你说我为什么要熬夜</p><p>因为我的生活是空虚的</p><p>那我问你，你为什么不在白天去填补你的空虚，而非要熬夜来填补你的空虚呢？</p><p>很简单</p><p>因为白天的世界是不属于你的</p><p>我为了要让自己的生活有意义</p><p>所以我不得不晚上减少我的睡眠时间，来获得我生活的意义</p><p>如果大家真的被内卷的世界所侵蚀过</p><p>经历过晚上的熬夜</p><p>你会发现那个熬夜是非常痛苦的</p><p>我为什么喜欢刷抖音</p><p>因为我除了刷大拇指这个动作之外</p><p>我没有任何一块肌肉可以用力了</p><p>可我为什么还是不愿意睡觉呢？</p><p>因为我知道我现在睡了</p><p>明天的世界又是别人的了</p><p>我又得去拼搏了</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金句</tag>
      
      <tag>辩论</tag>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低速信号常见BUG分析</title>
    <link href="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/"/>
    <url>/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1>开篇</h1><p>起因是一个背板的 I2C BUG，在测试主板到背板上的 I2C 时，出现在 ACK 位置<s>下冲现象</s>，与 TJ 同事沟通后才发现其实是Glitch（毛刺），不愧是老法师啊~</p><p>进而引申出此篇低速信号常见BUG的分析，花了几个小时到处搜索资料，结合自己一些分析理解，记录一下学习的过程</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/CLK_Glitch.png" alt="CLK_Glitch"></p><p>先解释下一些名词：</p><blockquote><p>Glitch（毛刺）：在原本预期的连续或稳定的信号中出现的短暂而异常的电压或电流波动，表现为瞬态尖峰或窄脉冲。</p><p>Overshoot（过冲；正脉冲信号）：过，就是超过，越过了预定电平门限<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这个门限在CMOS电平标准里指 VDD, VSS">[1]</span></a></sup>。</p><p>Undershoot（下冲；负脉冲信号）：下，就是不及，没有到达预定的电平门限。</p><p>Ringing（振铃）：反复的过冲与下冲，就形成了振铃</p></blockquote><h1>信号的毛刺</h1><p>毛刺产生的原因——通常是由于电路设计、制造缺陷、噪声耦合、信号切换速度过快或其他复杂的电气交互作用所引起。</p><h2 id="信号毛刺的产生原理-sup-id-fnref-2-class-footnote-ref-a-href-fn-2-rel-footnote-span-class-hint-top-hint-rounded-aria-label-毛刺glitch的产生与消除-https-www-cnblogs-com-iczero-p-17187349-html-2-span-a-sup">信号毛刺的产生原理<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[毛刺glitch的产生与消除](https://www.cnblogs.com/iczero/p/17187349.html)">[2]</span></a></sup></h2><blockquote><p>毛刺是一种形象的说法，它的产生归因于组合逻辑的竞争与冒险。</p></blockquote><h3 id="竞争-sup-id-fnref-3-class-footnote-ref-a-href-fn-3-rel-footnote-span-class-hint-top-hint-rounded-aria-label-竞争与冒险——随笔-https-www-cnblogs-com-IClearner-p-7233495-html-3-span-a-sup">竞争<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[竞争与冒险——随笔](https://www.cnblogs.com/IClearner/p/7233495.html)">[3]</span></a></sup></h3><blockquote><p><strong>竞争</strong>：在组合逻辑中，信号经由不同的路径达到某一会合点的时间有先有后，这种现象称为竞争。</p></blockquote><p>有两种情况会产生竞争：门电路两个输入信号同时向相反的逻辑电平跳变或同一信号经不同路径到达终点的时间有先有后的现象。</p><ul><li>例1：信号 A、B 不可能突变，需要经历一段极短的过渡时间。而门电路的传输时间也各不相同，故当 A、B 同时改变状态时可能在输出端产生虚假信号。</li></ul><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/A+B=Y.jpeg" alt="A+B=Y"></p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E6%AF%9B%E5%88%BA.jpeg" alt="传输时间不同导致毛刺"></p><ul><li>例2：同一信号经不同路径到达终点的时间有先后（或者两个不同信号变化不同步），结果在 <code>t1-t2</code> 时间内，电路输出端产生了 <code>Y=1</code> 的尖峰脉冲，不符合静态下，Y 恒为0的逻辑关系：</li></ul><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.jpeg" alt="不同路径"></p><p>结果，在 <code>t1-t2</code> 时间内，电路输出端产生了 <code>Y=1</code> 的尖峰脉冲，不符合静态下，Y 恒为0的逻辑关系：</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/9556a311e62717a87f24ab250e07ffea.jpeg" alt="信号变化不同步导致毛刺"></p><h3 id="冒险-sup-id-fnref-3-class-footnote-ref-a-href-fn-3-rel-footnote-span-class-hint-top-hint-rounded-aria-label-竞争与冒险——随笔-https-www-cnblogs-com-IClearner-p-7233495-html-3-span-a-sup">冒险<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[竞争与冒险——随笔](https://www.cnblogs.com/IClearner/p/7233495.html)">[3]</span></a></sup></h3><blockquote><p><strong>冒险</strong>：由于竞争而引起电路输出发生瞬间错误现象称为冒险。表现为输出端出现了设计预期之外的窄脉冲，常称其为毛刺。（可见，冒险是竞争产生的结果）</p></blockquote><p>冒险信号的脉冲宽度很小，常常只有<strong>数纳秒或数十纳秒</strong>，其<strong>频带带宽</strong>可达数百兆赫兹或更宽。在板级调试时，如果示波器的上限频率较低，会将幅度较大的毛刺显示为幅度较小的毛刺，甚至不易被察觉。</p><p>冒险按产生形式的不同可以分为<strong>静态冒险</strong>和<strong>动态冒险</strong>两大类。</p><ul><li><p>静态冒险：输入有变化，而输出不应变化时产生的单个窄脉冲</p></li><li><p>动态冒险：输入有变化，输出也应变化时产生的单个窄脉冲</p></li></ul><p><strong>动态冒险是由静态冒险引起的，因此存在动态冒险的电路也存在静态冒险。</strong></p><p>静态冒险根据产生条件的不同，分为<strong>功能冒险</strong>和<strong>逻辑冒险</strong>两大类。</p><ul><li><p>功能冒险：当有两个或两个以上输入信号同时产生变化时，在输出端产生毛刺</p></li><li><p>逻辑冒险：如果只有一个变量产生变化时，在输出端产生毛刺</p></li></ul><p><em>冒险往往会影响到逻辑电路的稳定性，因此要注意冒险的消除。</em></p><p>竞争与冒险的关系：<strong>有竞争不一定会产生冒险，但有冒险就一定有竞争</strong></p><h2 id="毛刺造成的危害-sup-id-fnref-2-class-footnote-ref-a-href-fn-2-rel-footnote-span-class-hint-top-hint-rounded-aria-label-毛刺glitch的产生与消除-https-www-cnblogs-com-iczero-p-17187349-html-2-span-a-sup">毛刺造成的危害<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[毛刺glitch的产生与消除](https://www.cnblogs.com/iczero/p/17187349.html)">[2]</span></a></sup></h2><p>当毛刺信号成为系统的启动信号，控制信号，握手信号，触发器的清零信号，预置信号，时钟信号，或锁存器的输入信号时就会产生<strong>逻辑错误</strong>；同时组合逻辑产生的毛刺也会<strong>增加</strong>系统<strong>功耗</strong>。</p><h2 id="毛刺的消除">毛刺的消除</h2><p>组合逻辑的毛刺通常总是存在，难于甚至无法消除，但是毛刺只有在<strong>异步设计</strong><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[FPGA设计精要：时钟同步与异步技术深度解析及最佳实践](https://blog.csdn.net/kiingking/article/details/140420683)">[4]</span></a></sup>中（连接到时钟、异步复位、锁存器的使能端）才存在问题，在<strong>同步设计</strong><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[FPGA设计精要：时钟同步与异步技术深度解析及最佳实践](https://blog.csdn.net/kiingking/article/details/140420683)">[4]</span></a></sup>中，由于寄存器在时钟沿才会动作，只要能满足时延要求，不出现在时钟的上升沿并且<strong>满足数据的建立和保持时间</strong>（由于毛刺很短，多为几纳秒，基本上都不可能满足数据的建立和保持时间），就能确保采样到稳定正确的结果，就不会对系统造成危害，毛刺虽然无法消除，但其造成的问题却可以消除。很幸运，我这里是 I2C 采用了同步设计。</p><blockquote><p>同步设计：同步设计是指电路中的所有信号都在一个<strong>共同的时钟信号</strong>的控制下进行操作。这意味着所有的状态变化都发生在时钟的上升沿或下降沿。同步设计的优点在于它简化了时序分析，因为所有信号的变化都被约束在一个可预测的时间点上。</p><p>异步设计：异步设计涉及处理<strong>不受统一时钟控制</strong>的信号，这可能是因为信号源自外部设备，或者是在FPGA内部的不同时钟域中。异步设计更加复杂，因为它涉及到解决不同信号之间的时间不确定性和亚稳态问题。</p></blockquote><p>其余方法请参考文末参考资料。</p><p>再说回我这边遇到的ACK位置的 CLK 出现毛刺现象，此时处于数据交换的时候，Master刚刚发送完数据，Slave进行应答，此时 ACK 为高，那应该为 NACK （ACK是低电平有效）。且测量时发现该 NACK存在不单调的情况，因为此时测量在Slave端，NACK 是Slave发送的，这里的不单调属于信号的反射，故我们进行了Master端的测量，发现NACK是正常的，符合预期，这是题外话。</p><p>处在这个主从交换控制权的位置，并且我得IPMB线是一转三的，我推测可能出现了静态冒险情况，信号造成了一定的干扰，耦合到了时钟上，导致了这一现象的发生，又被我们误判成了下过冲。更换了屏蔽线缆之后结果略有改善，一转三的线缆存在太多干扰了，一转一的就不会发生这种情况。</p><h1>过冲与下冲</h1><blockquote><p>过冲是指信号跳变的<strong>第一个</strong>峰值或谷值，它是在电源电平之上或参考地电平之下的额外电压效应；下冲是指信号跳变的<strong>下一个</strong>谷值或峰值。</p></blockquote><h2 id="影响与危害-sup-id-fnref-5-class-footnote-ref-a-href-fn-5-rel-footnote-span-class-hint-top-hint-rounded-aria-label-信号完整性与高速PCB设计（1）：过冲、欠冲、振铃-https-www-cnblogs-com-sunshine-jackie-p-18236714-5-span-a-sup">影响与危害<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[信号完整性与高速PCB设计（1）：过冲、欠冲、振铃](https://www.cnblogs.com/sunshine-jackie/p/18236714)">[5]</span></a></sup></h2><p>过冲与下冲都是不利的因素，过大的过冲电压经常长期性地冲击会造成器件的损坏，如图所示。严重的下冲会超过接收器件的门限而导致电路的逻辑错误。</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E8%BF%87%E5%86%B2%E4%B8%8B%E5%86%B2.png" alt="过冲下冲"></p><p>如果信号的下冲过大，可能会产生高低电平的误判，导致系统致命的逻辑错误，本应该为1的地方变成了0，0变成了1</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD.png" alt="逻辑判断"></p><p>与信号下冲不同，过冲并不会导致逻辑判断错误，但却可能给芯片带来潜在的累积性伤害，从而缩短其工作寿命，严重者可能会损坏芯片。如下图为AST2600 DataSheet关于过冲部分的说明</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/Spec.png" alt="Spec"></p><p>如果过冲信号在 1.3*VCC~4V 范围之内呢？4V 是所能允许的最大输入电压，不能越过这个门限。设想如果一个输入电平保持在 3.9V，又该如何评价这个信号质量（过冲）能否接受？对于芯片来讲是否安全呢？需要引入过冲/下冲的另一个评估参数： 过冲/下冲持续时间<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[过冲（overshoot）、下冲（Undershoot）的量化标准与评估实例](https://blog.csdn.net/qq_27655845/article/details/127015261)">[6]</span></a></sup>。一般来讲，<strong>过冲越高，持续时间越长，器件寿命会越短。</strong></p><p>虽然没有到达4V，但当持续时间 ≥ 5ns时，我们认为这样的过冲也是需要进行Debug的，以免较长时间的过冲使得芯片的可靠性降低。</p><h2 id="信号反射-sup-id-fnref-7-class-footnote-ref-a-href-fn-7-rel-footnote-span-class-hint-top-hint-rounded-aria-label-信号完整性之“过冲“（振铃）深度分析-https-www-cnblogs-com-Spring-Ltc-p-13512099-html-7-span-a-sup">信号反射<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[信号完整性之“过冲“（振铃）深度分析](https://www.cnblogs.com/Spring-Ltc/p/13512099.html)">[7]</span></a></sup></h2><blockquote><p><strong>产生过冲和下冲的本质原因是：传输路径上的信号的反射导致</strong></p></blockquote><p>反射是引起SI的一个最基本因素，信号在传输线传播过程中，一旦它所感受到的传输线瞬时阻抗发生变化，那么就必将有发射发生。</p><h3 id="反射及反射系数">反射及反射系数</h3><p>设绿色阻抗为 Z1，蓝色阻抗为 Z2，信号经过两个阻抗不同的区域，在交界处A处，电压和电流不能产生突变（若电压不连续，将产生无穷大的电场；若电流不连续，将产生无穷大的磁场）。</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E5%8F%8D%E5%B0%84.png" alt="反射"></p><p>若 Z1 ≠ Z2，则关系式 V1 =I1 × Z1 ; V2 =I2 × Z2 ，无法同时满足电压和电流连续的条件V1 = V2,I1 = I2 ，故只能从电磁波反射的角度进行分析，如下所示。<br>　　信号由区域1往区域2传输的过程中，入射(incident)信号、反射信号(reflect)、传输信号(transfer)分别如下图表示：</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/image-20240723201105501.png" alt><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/image-20240723201133580.png" alt></p><p>分界面两侧的电压相等，有 Vinc + Vref = Vtra ；</p><p>分界面两侧的电流相等，有Iinc - Iref = Itra   ；</p><p>再有 Iinc × Z1 = Vinc  ；Iref × Z1 = Vref  ；Itra × Z1 = Vtra  ；</p><p>由以上5个等式可以推导得出：</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/5a03f66e3eabe2571f803f8ef035db29.png" alt></p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/7e765f6c54522fa6e08c0be15f09e17a.png" alt></p><h3 id="建立模型">建立模型</h3><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%A8%A1%E5%9E%8B.png" alt="模型"></p><h3 id="展开时间轴，计算实时反射波形">展开时间轴，计算实时反射波形</h3><p>下面举个栗子</p><p>设传输线阻抗Rz=30Ω，源端串接的匹配电阻Rs=10Ω，则传输线左端A点反射系数为 (10 - 30)/(10 + 30) = -0.5,右端B点反射系数为 (+∞ - 30)/(+∞ + 30) = 1。</p><p>设初始状态都为低电平0.0V，T0时刻源端跳变为3.3V，发送逻辑高电平信号，末端B点的电压变化如下。</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%A8%A1%E5%9E%8B%E8%AE%A1%E7%AE%97.png" alt="模型计算"></p><p>T1时刻，由于电阻分压，传输线左端A点电压为3.3*30/(10+40)=2.475V，抽象理解为T1时刻有一个+2.475V的信号在传输线上向B点传播；</p><p>T2时刻，该信号在B点产生全反射(反射系数为1)，T2时刻B点电压为原始信号、入射信号、反射信号的叠加，即0+2.475+2.475 = 4.95V；</p><p>T3时刻，末端的一次反射信号到达A点，由于阻抗不匹配，反射电压为2.475 * (-0.5）=-1.2375V，此时A点电压也为原始信号、入射信号、反射信号的叠加；</p><p>T4时刻，源端的一次反射信号到达B点，同理计算末端B点电压为4.95-1.2375-1.2375 = 2.475V；</p><p>T5时刻，末端的二次反射信号到达A点…</p><p>T6时刻，源端的二次反射信号达到B点，如上图所示计算B点电压为 3.7125V</p><p>…</p><p>在理想情况（无损传输）下，信号会在传输线A、B两端无休止的反射振荡，反射电压的幅值越来越趋近于0，在实际中信号在传输过程中有衰减，最终趋于稳态。</p><hr><p>上面的看起来如果比较难理解的话，可以看看这个例子，简单点可以将主板上铜线看作水管，电信号看作水，从水厂到用户家里经过很多水管，这些水管肯定有粗有细，水流从细（阻抗大）的水管流向粗（阻抗小）的，流速肯定比较快（信号频率变快了），但是流出来的量并不多，占不满水管（电压相低）；水流从粗的水管突然流向细的，快将水管占满了（电压升高），流速就没有之前从细水管的里面出来那么快了（频率降低），而且势必会被反弹回来一部分，这就是信号的反射。水锤效应、山谷的回音也是信号反射的另一种体现。</p><h2 id="阻抗匹配-sup-id-fnref-7-class-footnote-ref-a-href-fn-7-rel-footnote-span-class-hint-top-hint-rounded-aria-label-信号完整性之“过冲“（振铃）深度分析-https-www-cnblogs-com-Spring-Ltc-p-13512099-html-7-span-a-sup">阻抗匹配<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[信号完整性之“过冲“（振铃）深度分析](https://www.cnblogs.com/Spring-Ltc/p/13512099.html)">[7]</span></a></sup></h2><blockquote><p><strong>信号反射的本质原因是：传输链路的阻抗不匹配</strong></p></blockquote><p>根据这个来进行Debug，只需要调整线路的串阻进行阻抗匹配即可，一般比较成熟的设计中都会在信号输出端加一个匹配电阻，在Layout的时候这颗电阻尽量的靠近源端器件的输出管脚，算是一个经验设计方法。实际上， 其实这个小电阻的作用就是为了解决信号反射问题。而且随着电阻的加大，振铃会消失，但你会发现信号上升沿不再那么陡峭了，串联电阻是为了减小反射波，避免反射波叠加引起过冲。这个解决方法叫阻抗匹配，一定要注意阻抗匹配，阻抗在信号完整性问题中占据着极其重要的地位。</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E5%8C%B9%E9%85%8D%E4%B8%B2%E9%98%BB.png" alt="匹配串阻"></p><p>假设我传输线特性阻抗为50ohm，负载阻抗为75ohm，用Python进行模拟匹配电阻和反射系数之间的关系</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E9%98%BB%E6%8A%97%E5%8C%B9%E9%85%8D%E5%AF%B9%E5%8F%8D%E5%B0%84%E7%B3%BB%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D.png" alt="阻抗匹配对反射系数的影响"></p><p>随着我匹配电阻不断的加大，反射系数也在不断的变小</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib.font_manager <span class="hljs-keyword">import</span> FontProperties<br><br><span class="hljs-comment"># 设置matplotlib的字体，防止中文乱码</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># 指定默认字体为黑体</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 解决负号显示问题</span><br><br><span class="hljs-comment"># 定义传输线参数</span><br>Z0 = <span class="hljs-number">50.0</span>  <span class="hljs-comment"># 传输线的特性阻抗</span><br>ZL = <span class="hljs-number">75.0</span>  <span class="hljs-comment"># 负载阻抗</span><br><br><span class="hljs-comment"># 阻抗匹配电阻值，可以根据需要修改</span><br>R_match = <span class="hljs-number">20.0</span>  <span class="hljs-comment"># 假设的匹配电阻值</span><br><br><span class="hljs-comment"># 计算阻抗变换后的负载阻抗</span><br>Z_transformed = Z0 * (R_match / (Z0 + R_match))<br><br><span class="hljs-comment"># 计算反射系数</span><br>Gamma = (Z_transformed - Z0) / (Z_transformed + Z0)<br><br><span class="hljs-comment"># 打印反射系数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;反射系数（阻抗匹配后）: <span class="hljs-subst">&#123;Gamma:<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 绘制反射系数随匹配电阻变化的图</span><br>R_values = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">500</span>)  <span class="hljs-comment"># 假设的匹配电阻范围</span><br>Gamma_values = [((R/(Z0 + R)) - <span class="hljs-number">1</span>) / ((R/(Z0 + R)) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> R <span class="hljs-keyword">in</span> R_values]<br><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>plt.plot(R_values, np.<span class="hljs-built_in">abs</span>(Gamma_values), label=<span class="hljs-string">&#x27;反射系数幅度&#x27;</span>)<br>plt.axvline(x=R_match, color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, label=<span class="hljs-string">f&#x27;当前匹配电阻值: <span class="hljs-subst">&#123;R_match&#125;</span>&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;匹配电阻值 (欧姆)&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;反射系数幅度&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;阻抗匹配对反射系数的影响&#x27;</span>)<br>plt.legend()<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>模拟实际波形来看看，以下是Python实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 系统初始条件</span><br>DataNum = <span class="hljs-number">100</span>  <span class="hljs-comment"># 100个数据模拟波形</span><br>StartNum = <span class="hljs-number">30</span>  <span class="hljs-comment"># 30个起始数据，方便对比</span><br>SourceRes = <span class="hljs-number">10.0</span>  <span class="hljs-comment"># 源端电阻，根据需要修改</span><br>LineRes = <span class="hljs-number">30.0</span>  <span class="hljs-comment"># 传输线电阻</span><br>StartVoltage = <span class="hljs-number">0.0</span>  <span class="hljs-comment"># 初始电平</span><br>TailVoltage = <span class="hljs-number">3.3</span>  <span class="hljs-comment"># 跳变后电平</span><br><br><span class="hljs-comment"># 计算反射系数</span><br>ReflectTail = <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 末端反射系数</span><br>ReflectSource = (SourceRes - LineRes) / (SourceRes + LineRes)  <span class="hljs-comment"># 源端反射系数</span><br>VoltageReflectSource = (TailVoltage - StartVoltage) * LineRes / (SourceRes + LineRes)  <span class="hljs-comment"># 传输线起始端电压</span><br><br><span class="hljs-comment"># 初始化数据数组</span><br>OutputData = np.zeros(DataNum)<br><br><span class="hljs-comment"># 添加初始数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(StartNum):<br>    OutputData[i] = StartVoltage<br><br><span class="hljs-comment"># 计算保存数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(StartNum, DataNum):<br>    OutputData[i] = OutputData[i - <span class="hljs-number">1</span>] + (VoltageReflectSource + VoltageReflectSource * ReflectTail)<br>    VoltageReflectSource *= ReflectSource * ReflectTail<br><br><span class="hljs-comment"># 绘制波形图</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># 设置图形的大小</span><br>plt.plot(OutputData, label=<span class="hljs-string">&#x27;Voltage Waveform&#x27;</span>)  <span class="hljs-comment"># 绘制波形图</span><br>plt.title(<span class="hljs-string">&#x27;Voltage Reflection Waveform&#x27;</span>)  <span class="hljs-comment"># 添加标题</span><br>plt.xlabel(<span class="hljs-string">&#x27;Time&#x27;</span>)  <span class="hljs-comment"># 添加x轴标签</span><br>plt.ylabel(<span class="hljs-string">&#x27;Voltage&#x27;</span>)  <span class="hljs-comment"># 添加y轴标签</span><br>plt.legend()  <span class="hljs-comment"># 显示图例</span><br>plt.grid(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 显示网格</span><br>plt.show()  <span class="hljs-comment"># 显示图形</span><br></code></pre></td></tr></table></figure><p>通过改变源端电阻阻值，得到以下模拟数据，分别为10ohm、20ohm、30ohm、40ohm、50ohm、60ohm的波形结果</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%BA%90%E7%AB%AF%E7%94%B5%E9%98%BB10%CE%A9.png" alt="源端电阻10Ω"></p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%BA%90%E7%AB%AF%E7%94%B5%E9%98%BB20%CE%A9.png" alt="源端电阻20Ω"></p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%BA%90%E7%AB%AF%E7%94%B5%E9%98%BB30%CE%A9.png" alt="源端电阻30Ω"></p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%BA%90%E7%AB%AF%E7%94%B5%E9%98%BB40%CE%A9.png" alt="源端电阻40Ω"></p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%BA%90%E7%AB%AF%E7%94%B5%E9%98%BB50%CE%A9.png" alt="源端电阻50Ω"></p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%BA%90%E7%AB%AF%E7%94%B5%E9%98%BB60%CE%A9.png" alt="源端电阻60Ω"></p><ul><li><p>发生从0到1跳变时，当源端电阻小于传输线电阻时，信号变化比较快（上升时间较短），但是会伴随着过冲的产生，影响信号的完整性；</p></li><li><p>当源端电阻大于传输线电阻时，信号上升相对比较平缓，能有效解决过冲问题，但是增大了上升时间，限制了信号的传输速度；</p></li><li><p>只有当源端电阻和传输线电阻相等时（即阻抗匹配状态），信号质量最接近理想状态。</p></li></ul><p>当多个反射信号和原信号叠加则会导致反复的过冲与下冲，反复的过冲和下冲则会引起<strong>振铃</strong>。这增加了信号稳定所需要的时间，从而也影响了系统稳定的时序。</p><h1>振铃</h1><blockquote><p>振铃现象是一种高频波动，主要表现为电路或系统中的振荡和失真。它的产生原因可以是信号幅度过大、相位差不当、负载阻抗变化等多种因素。</p></blockquote><p>具体来说，在反馈电路中，当输入信号与反馈信号相位差发生改变时，如果其幅度超过一定阈值，则可能会引起振铃现象。这种情况下，输出信号会反复振荡，并逐渐失真，最终导致整个电路或系统的失效。</p><p><img src="/2024/07/24/%E4%BD%8E%E9%80%9F%E4%BF%A1%E5%8F%B7%E5%B8%B8%E8%A7%81BUG%E5%88%86%E6%9E%90/%E6%8C%AF%E9%93%83.jpg" alt="振铃"></p><p>实际上，要解决这个问题，我们可以选择合适的开关管、采用滤波器等，还有在布线的时候尽量的减少环路的面积，这样也能够减少寄生电感/杂散电感，然而在项目中还是会以高速信号为主进行布线，所以最有效的还是进行阻抗的匹配，当阻抗匹配后，过冲问题会得到解决，同样的振铃也会一起跟着消失。</p><h1>总结</h1><p>言而总之，总而言之，信号的Glitch也好，过冲、下冲、振铃也好，看了那么多解释和例子之后对信号完整性的理解又多了一些，好像归根结底就是阻抗不匹配<sub>（小声逼逼）</sub>，有很多东西都可以延展再延展，一开始写就停不下来，但是强迫自己停下来吧，毕竟手头还有活要干呢（叹气= =）,信号完整性真的涉及到了太多东西，就本篇来看，需要掌握数电、模电、基础的电路知识，会<s>问ChatGPT</s>点编程，知道怎么测试…想要做一些扩展的话，更得熟练掌握数电、模电、电路。</p><p>当然还有很多东西没有提到的，比如说串扰啊、抖动啊等等，每一点又能分几小点，每个小点又能叭叭一堆。</p><h1>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这个门限在CMOS电平标准里指 VDD, VSS<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/iczero/p/17187349.html">毛刺glitch的产生与消除</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/IClearner/p/7233495.html">竞争与冒险——随笔</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/kiingking/article/details/140420683">FPGA设计精要：时钟同步与异步技术深度解析及最佳实践</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.cnblogs.com/sunshine-jackie/p/18236714">信号完整性与高速PCB设计（1）：过冲、欠冲、振铃</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://blog.csdn.net/qq_27655845/article/details/127015261">过冲（overshoot）、下冲（Undershoot）的量化标准与评估实例</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://www.cnblogs.com/Spring-Ltc/p/13512099.html">信号完整性之“过冲“（振铃）深度分析</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://www.cnblogs.com/jacklong-yin/p/9767098.html">信号反射的几个重要体现（过冲、下冲、振铃）及电路设计</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://www.21ic.com/a/966412.html">信号毛刺是怎么回事</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>信号完整性</category>
      
      <category>低速信号</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号测试</tag>
      
      <tag>BUG</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统安装驱动时报错--Kernel相关</title>
    <link href="/2024/07/18/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99-Kernel%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/07/18/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99-Kernel%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1>问题背景</h1><p>在安装网卡、GPU 驱动时出现Kernel相关的报错，具体表现如下</p><p>安装 WX1860 芯片网卡驱动时，使用 <code>make</code> 命令出现报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# make<br>common.mk:98: *** Kernel header files not <span class="hljs-keyword">in</span> any of the expected locations.<br>common.mk:99: *** Install the appropriate kernel development package, e.g.<br>common.mk:100: *** kernel-devel, <span class="hljs-keyword">for</span> building kernel modules and try again. Stop.<br></code></pre></td></tr></table></figure><p>安装 NVIDIA GPU 驱动时出现如下报错</p><p><img src="/2024/07/18/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99-Kernel%E7%9B%B8%E5%85%B3/%E6%8A%A5%E9%94%99.png" alt="报错"></p><h1>问题分析<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Centos 安装网卡驱动make时报错Kernel header files not in any of the expected locations.解决办法之一：https://blog.csdn.net/qq_43530066/article/details/129122611">[1]</span></a></sup></h1><p>报错的意思就是内核和内核头文件版本不一致，找不到当前内核源的内核代码树</p><p>我们可以先查看当前的系统内核信息，获取到当前内核版本为：<code>4.19.113.40.nfs4.x8_64</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p><img src="/2024/07/18/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99-Kernel%E7%9B%B8%E5%85%B3/%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC.png" alt="查看当前内核版本"></p><p>查看本地yum库中所有Kernel信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list |grep kernel<br></code></pre></td></tr></table></figure><p><img src="/2024/07/18/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99-Kernel%E7%9B%B8%E5%85%B3/yum%E5%8C%85.png" alt="yum包"></p><p>第一列和第二列分别是名称和版本，第三列代表yum库 <code>anaconda</code> 、<code>base</code>、<code>updates</code> ，前面有 @ 符号代表已安装<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Linux基础——yum工具详解：https://blog.csdn.net/CityzenOldwang/article/details/61614707">[2]</span></a></sup></p><p>保证我们使用的版本是一致的就行，我直接安装较新版本，分别执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install kernel-4.19.113-59.nfs4<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install kernel-headers-4.19.113-59.nfs4<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install kernel-devel-4.19.113-59.nfs4<br></code></pre></td></tr></table></figure><p>当然也可以把 <code>headers</code> 和 <code>devel</code>  全部更新成和内核版本 <code>4.19.113.40.nfs4.x8_64</code>一样的</p><p><img src="/2024/07/18/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99-Kernel%E7%9B%B8%E5%85%B3/%E5%AE%89%E8%A3%85%E6%88%96%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%A4%B4.png" alt="安装或更新内核头"></p><p>重新使用 <code>make</code> 命令安装网卡驱动/安装 NVIDIA GPU 驱动，问题解决</p><h1>安装驱动</h1><h2 id="网讯千兆网卡WX1860驱动安装">网讯千兆网卡WX1860驱动安装</h2><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make modules_install<br></code></pre></td></tr></table></figure><p>加载驱动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">modprobe ngbe<br><span class="hljs-comment"># 仅安装完首次需要手动加载，若重启系统，系统会自动加载驱动</span><br></code></pre></td></tr></table></figure><p>查看驱动是否加载成功（环境上需安装网迅千兆网卡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@SW ~]# lsmod | grep ngbe <br>ngbe 208399 0 <br></code></pre></td></tr></table></figure><p>此时驱动已加载成功</p><h2 id="NVIDIA-驱动安装">NVIDIA 驱动安装</h2><p>NV 驱动官网<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="NV驱动下载：https://www.nvidia.com/Download/index.aspx?lang=cn">[3]</span></a></sup>按照型号要求进行下载，系统中直接执行安装脚本按要求一步一步安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./NVIDIA-Linux-x86_64-550.54.15.run<br></code></pre></td></tr></table></figure><h1>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Centos 安装网卡驱动make时报错Kernel header files not in any of the expected locations.解决办法之一：<a href="https://blog.csdn.net/qq_43530066/article/details/129122611">https://blog.csdn.net/qq_43530066/article/details/129122611</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Linux基础——yum工具详解：<a href="https://blog.csdn.net/CityzenOldwang/article/details/61614707">https://blog.csdn.net/CityzenOldwang/article/details/61614707</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>NV驱动下载：<a href="https://www.nvidia.com/Download/index.aspx?lang=cn">https://www.nvidia.com/Download/index.aspx?lang=cn</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>搬砖日记</category>
      
      <category>系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>疑难杂症</tag>
      
      <tag>系统</tag>
      
      <tag>驱动</tag>
      
      <tag>工作日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青龙面板搭建教程</title>
    <link href="/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <url>/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>开篇</h1><p>忘记了是哪一年的哪一天，人总有那么几天是心里很痒痒的，本来我只是打算翻出来<s>色色的</s>学习的，结果无意之间看到一些非常有趣的东西，不得不说 GitHub 真是个好东西啊</p><h1>青龙面板</h1><p>正题就是青龙面板<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="whyour/qinglong:https://github.com/whyour/qinglong">[1]</span></a></sup>。青龙是 <a href="https://github.com/whyour">whyour</a> 大佬写的一个定时任务管理平台，支持 Python3、JavaScript、Shell、Typescript，简单来说就是可以定时运行一些脚本，就比如说薅羊毛、签到、抢购等等，谁会跟羊毛过意不去呢？</p><p>青龙面板涵盖以下功能</p><ul><li><p>支持多种脚本语言（python3、JavaScript、shell、typescript）</p></li><li><p>支持在线管理脚本、环境变量、配置文件</p></li><li><p>支持在线查看任务日志</p></li><li><p>支持秒级任务设置</p></li><li><p>支持系统级通知</p></li><li><p>支持暗黑模式</p></li><li><p>支持手机端操作</p></li></ul><h2 id="搭建部署">搭建部署</h2><p>推荐使用Docker进行部署，NAS或者面板（如宝塔、1Panel等）可以直接在镜像仓库搜索进行部署，如果是云服务器等先下载安装docker，再进行青龙的部署，从大佬的README中可以看到相关部署的教程，我这里搬运下</p><p><code>latest</code> 镜像是基于 <code>alpine</code> 构建，<code>debian</code> 镜像是基于 <code>debian-slim</code> 构建。如果需要使用 <code>alpine</code> 不支持的依赖，建议使用 <code>debian</code> 镜像，下面是拉取镜像命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull whyour/qinglong:latest<br>docker pull whyour/qinglong:debian<br></code></pre></td></tr></table></figure><p>下面进行部署青龙</p><h3 id="docker-推荐">docker (推荐)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># curl -sSL get.docker.com | sh</span><br>docker run -dit \<br>  -v <span class="hljs-variable">$PWD</span>/ql/data:/ql/data \<br>  <span class="hljs-comment"># 冒号后面的 5700 为默认端口，如果设置了 QlPort, 需要跟 QlPort 保持一致</span><br>  -p 5700:5700 \<br>  <span class="hljs-comment"># 部署路径非必须，比如 /test</span><br>  -e QlBaseUrl=<span class="hljs-string">&quot;/&quot;</span> \<br>  <span class="hljs-comment"># 部署端口非必须，当使用 host 模式时，可以设置服务启动后的端口，默认 5700</span><br>  -e QlPort=<span class="hljs-string">&quot;5700&quot;</span> \<br>  --name qinglong \<br>  --hostname qinglong \<br>  --restart unless-stopped \<br>  whyour/qinglong:latest<br></code></pre></td></tr></table></figure><h3 id="docker-compose-推荐">docker-compose (推荐)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="hljs-built_in">mkdir</span> qinglong<br>wget https://raw.githubusercontent.com/whyour/qinglong/master/docker/docker-compose.yml<br><br><span class="hljs-comment"># 启动</span><br>docker-compose up -d<br><span class="hljs-comment"># 停止</span><br>docker-compose down<br></code></pre></td></tr></table></figure><p>到此就完成了，然后在本地打开青龙面板界面，默认端口为5700，打开你的浏览器，访问 <a href="http://127.0.0.1:5700/">http://127.0.0.1:5700</a>可进入安装向导，设置账户密码，按要求一步一步即可，推送可先不填，如果没有进入配置向导，可在终端执行以下命令查看账号密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it qinglong <span class="hljs-built_in">cat</span> /ql/config/auth.json<br></code></pre></td></tr></table></figure><p>看到如下界面就完成了</p><p><img src="/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E9%9D%92%E9%BE%99%E9%A6%96%E9%A1%B5.png" alt="青龙首页"></p><h2 id="拔毛行动">拔毛行动</h2><h3 id="拉取脚本仓库">拉取脚本仓库</h3><p>在拉取脚本仓库之前需要先了解下拉取命令的格式，青龙有个内置命令：<code>ql</code> ，描述如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新并重启青龙</span><br>ql update<br><span class="hljs-comment"># 运行自定义脚本extra.sh</span><br>ql extra<br><span class="hljs-comment"># 添加单个脚本文件</span><br>ql raw &lt;file_url&gt;<br><span class="hljs-comment"># 添加单个仓库的指定脚本</span><br>ql repo &lt;repo_url&gt; &lt;whitelist&gt; &lt;blacklist&gt; &lt;dependence&gt; &lt;branch&gt; &lt;extensions&gt;<br><span class="hljs-comment"># 删除旧日志</span><br>ql rmlog &lt;days&gt;<br><span class="hljs-comment"># 启动tg-bot</span><br>ql bot<br><span class="hljs-comment"># 检测青龙环境并修复</span><br>ql check<br><span class="hljs-comment"># 重置登录错误次数</span><br>ql resetlet                                                  <br><span class="hljs-comment"># 禁用两步登录</span><br>ql resettfa<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>file_url</td><td>脚本地址</td></tr><tr><td>repo_url</td><td>仓库地址</td></tr><tr><td>whitelist</td><td>拉取仓库时的白名单，即就是需要拉取的脚本的路径包含的字符串，多个竖线分割</td></tr><tr><td>blacklist</td><td>拉取仓库时的黑名单，即就是需要拉取的脚本的路径不包含的字符串，多个竖线分割</td></tr><tr><td>dependence</td><td>拉取仓库需要的依赖文件，会直接从仓库拷贝到scripts下的仓库目录，不受黑名单影响，多个竖线分割</td></tr><tr><td>extensions</td><td>拉取仓库的文件后缀，多个竖线分割</td></tr><tr><td>branch</td><td>拉取仓库的分支</td></tr><tr><td>days</td><td>需要保留的日志的天数</td></tr><tr><td>file_path</td><td>任务执行时的文件路径</td></tr></tbody></table><p>对上述命令有个初步了解之后，再看拉库命令就明了很多了，首先我们先拉个<a href="https://github.com/6dylan6/jdpro">6dy</a>大佬写的JD签到做任务的库6dylan6/jdpro<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="6dylan6/jdpro:https://github.com/6dylan6/jdpro">[2]</span></a></sup>，登陆后选择订阅管理创建订阅，在名称一行输入拉库指令如下：</p><p>国内机（带代理）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ql repo https://js.jdpro.site/https://github.com/6dylan6/jdpro.git <span class="hljs-string">&quot;jd_|jx_|jddj_&quot;</span> <span class="hljs-string">&quot;backUp&quot;</span> <span class="hljs-string">&quot;^jd[^_]|USER|JD|function|sendNotify|utils&quot;</span><br></code></pre></td></tr></table></figure><p>默认代理拉不了，自行找可用代理</p><p>国外机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ql repo https://github.com/6dylan6/jdpro.git <span class="hljs-string">&quot;jd_|jx_|jddj_&quot;</span> <span class="hljs-string">&quot;backUp&quot;</span> <span class="hljs-string">&quot;^jd[^_]|USER|JD|function|sendNotify|utils&quot;</span><br></code></pre></td></tr></table></figure><p>定时任务随意，要遵循crontab表达式规则，可以使用这个在线工具 <a href="https://tool.lu/crontab">https://tool.lu/crontab</a> 里面也有详细说明每个字段的意思</p><p><img src="/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E5%88%9B%E5%BB%BA%E8%AE%A2%E9%98%85.png" alt="创建订阅"></p><p>创建完成后可在订阅管理中看到刚刚创建的订阅，此时点击右侧运行等待拉库完成即可，后面会根据你设置的定时规则自动拉库，这样就做到自动更新脚本了</p><p><img src="/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E8%BF%90%E8%A1%8C%E8%AE%A2%E9%98%85.png" alt="运行订阅"></p><p>点击日志可以查看到拉库状态，我这里是已经拉完了，实际第一次拉库会显示添加XXX任务成功的log</p><p><img src="/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E6%8B%89%E5%BA%93.png" alt="拉库"></p><p>此时点击左侧定时任务，便可查看到刚刚拉下来的脚本了</p><p><img src="/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" alt="定时任务"></p><p>这里的定时规则可以根据自己的需求改动，右侧也可以手动运行，查看日志看看是否运行错误，顶部更多可以创建视图进行分类，当脚本过多时不会显得太乱</p><h3 id="安装依赖">安装依赖</h3><p>我们只拉库还不行，此时运行可以发现，肯定是会报错的，通常表现为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 缺少依赖</span><br>Error: Cannot find module ‘xx’<br><br><span class="hljs-string">&#x27;xxxx&#x27;</span> module not found<br><br><span class="hljs-comment"># 缺少Python依赖</span><br>ModuleNotFoundError: No module named ‘xxx’<br><br><span class="hljs-comment"># 拉库不完整，缺少相应文件，检查拉库命令重新拉库</span><br>Error: Cannot find module ‘./xx’<br></code></pre></td></tr></table></figure><p>对于缺少依赖的问题，可以在左侧依赖管理进行安装，通常需要安装的依赖如下所示：</p><p>NodeJs:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">crypto-<span class="hljs-keyword">js</span><br>prettytable<br>dotenv<br>jsdom<br>date-fns<br>tough-cookie<br>tslib<br>ws@<span class="hljs-number">7.4</span><span class="hljs-number">.3</span><br>ts-md5<br>jsdom -g<br>jieba<br><span class="hljs-built_in">fs</span><br>form-data<br>json5<br><span class="hljs-meta">global</span>-agent<br>png-<span class="hljs-keyword">js</span><br>@types/node<br>require<br>typescript<br><span class="hljs-keyword">js</span>-base64<br>axios<br>moment<br></code></pre></td></tr></table></figure><p>Python3:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">requests<br><span class="hljs-selector-tag">canvas</span><br>ping3<br>jieba<br>PyExecJS<br>aiohttp<br></code></pre></td></tr></table></figure><p>Linux:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bizCode</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bizMsg</span><br><span class="hljs-keyword"></span>lxm<br></code></pre></td></tr></table></figure><p>安装失败可以在 系统设置 - 依赖设置 里面配置代理或者镜像源</p><p>我这里用的是这个</p><p>Node 软件包镜像源：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//registry.npmmirror.com</span><br></code></pre></td></tr></table></figure><p>Python 软件包镜像源：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple</span><br></code></pre></td></tr></table></figure><p>Linux 软件包镜像源：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//mirrors.aliyun.com</span><br></code></pre></td></tr></table></figure><p>当然还是推荐对应的一键安装脚本QLDependency<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="FlechazoPh/QLDependency:https://github.com/FlechazoPh/QLDependency">[3]</span></a></sup>：</p><p>一键安装单独青龙的依赖<br>国内版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it qinglong bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/FlechazoPh/QLDependency/main/Shell/QLOneKeyDependency.sh | bash)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>国外版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it qinglong bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/FlechazoPh/QLDependency/main/Shell/QLOneKeyDependency.sh | bash)</span>&quot;</span><br></code></pre></td></tr></table></figure><p><strong>【更新】</strong> 版本号 2.12+ 的新版本青龙安装失败请尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it qinglong bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/FlechazoPh/QLDependency/main/Shell/XinQLOneKey.sh | bash)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>其中 -it 后面的 qinglong 是容器的名字，替换成自己的就行，安装完成后重启下镜像即可。</p><h3 id="环境变量">环境变量</h3><p>此时再去手动运行定时任务的时候，发现就可以运行了，但是又出现了一个问题，提示没有环境变量JD_COOKIE，我们这时候就需要抓取JD_COOKIE添加到环境变量中，具体抓取方法参考<a href="https://mtnxu.com/2024/07/07/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96JD-COOKIE/">这里</a>，添加到环境变量中<img src="/2024/07/14/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/%E5%88%9B%E5%BB%BAJD_COOKIE%E5%8F%98%E9%87%8F.png" alt="创建JD_COOKIE变量"></p><p>也可以写在配置文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JD_COOKIE=<span class="hljs-string">&quot;xxxxxx&quot;</span><br></code></pre></td></tr></table></figure><p>到这一步，这个羊毛基本算是可以薅下来啦！当然，实际运行和添加的一些其他的环境变量还是需要多看看jdpro的README和ISSUES还有一些教程，还有设置配置文件（拉库、任务、推送、环境变量等）、配置代理池（防止黑号）、推送服务等等需要自行摸索下，只要肯折腾都不难~</p><h1>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>whyour/qinglong:<a href="https://github.com/whyour/qinglong">https://github.com/whyour/qinglong</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>6dylan6/jdpro:<a href="https://github.com/6dylan6/jdpro">https://github.com/6dylan6/jdpro</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>FlechazoPh/QLDependency:<a href="https://github.com/FlechazoPh/QLDependency">https://github.com/FlechazoPh/QLDependency</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>有趣的折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
      <tag>折腾</tag>
      
      <tag>青龙面板</tag>
      
      <tag>薅羊毛</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青龙脚本之如何获取JD COOKIE</title>
    <link href="/2024/07/07/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96JD-COOKIE/"/>
    <url>/2024/07/07/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96JD-COOKIE/</url>
    
    <content type="html"><![CDATA[<h2 id="Cookie">Cookie</h2><p>Cookie 代表曲奇，饼干的意思。意思就是一些网站的数据信息，当我们打开 JD 时，第一次需要进行登录，过了几天再打开 JD 时，发现直接就进去了，我们的账号不需要再次登录了，这是因为浏览器保存了网站的 Cookie 信息。</p><h2 id="如何获取Cookie">如何获取Cookie</h2><p>以 JD 为例，我们要获取 Cookie 首先登录京东移动版 <a href="https://m.jd.com"><code>m.jd.com</code></a> 推荐使用手机验证码的方式登录，Cookie 有效期较长，一般为30天</p><p><img src="/2024/07/07/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96JD-COOKIE/%E7%99%BB%E5%BD%95.png" alt="登录"></p><p>登录完成后<strong>点击右下角我的</strong>，再按键盘上 <code>F12</code> 打开开发者模式，一定要登录上之后再按 <code>F12</code> 不然过不了滑块验证。</p><p><img src="/2024/07/07/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96JD-COOKIE/%E5%A4%8D%E5%88%B6cookie.png" alt="复制cookie"></p><p><code>F12</code> 后如图所示，<strong>点击 Network（网络）</strong> ，之后选择 All 或者 Doc 都行，我这边每次都在 Doc 抓，只有一项，比较方便，不用在所有的包里找了，在 Headers（请求头）里面找到 Cookie（饼干），字段很长，全部复制即可</p><p><img src="/2024/07/07/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96JD-COOKIE/cookie%E8%8E%B7%E5%8F%96.png" alt="cookie获取"></p><p>实际上，我们需要的只是 <code>pt_key</code> 和 <code>pt_pin</code> ，所以还有另一种方法可以获取</p><p><img src="/2024/07/07/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC%E4%B9%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96JD-COOKIE/%E5%AE%9E%E9%99%85%E9%9C%80%E8%A6%81%E5%80%BC.png" alt="实际需要值"></p><p>点击 Application ，在左侧找到Cookies，这里面包含刚刚复制的所有内容，找到 Name 为 <code>pt_key</code> 和 <code>pt_pin</code> 的，Value 就是它的值，按照下面这个格式就可以</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">pt_key</span>=xxxxxxxxxxxxxxx; <span class="hljs-attribute">pt_pin</span>=jd_xxxxxxxxxxxx<br></code></pre></td></tr></table></figure><p>最后把获取到的 cookie 复制到环境变量中即可</p><p><u><em><strong>PS: Cookie 是私密内容，请不要随意发送，有可能产生损失！！！</strong></em></u></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>有趣的折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本</tag>
      
      <tag>折腾</tag>
      
      <tag>青龙面板</tag>
      
      <tag>薅羊毛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电信电视盒子中兴B860AV2.1-T 刷固件变当贝盒子</title>
    <link href="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/"/>
    <url>/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>周末在家没事干，打扫卫生的时候发现了之前在昆山的时候办宽带送的机顶盒，食之无味弃之可惜啊，想着不然刷个当贝玩玩把。网上很多类似的教程，资料相对来说比较方便，直接进入正题把！</p><hr><h1>正题</h1><h2 id="拆机短接">拆机短接</h2><p>第一步先拆机，取出PCB板</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E6%8B%86%E6%9C%BA%E8%A6%81%E5%BD%93%E5%BF%83%E5%93%A6.jpg" alt="拆机要当心哦"></p><p>主板全貌，一塌糊涂，各种减配，用料很一般</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E4%B8%BB%E6%9D%BF.jpg" alt="主板"></p><p>短接C9A8即可识别线刷，先拔掉盒子所有连接线，插上USB（此时盒子指示灯不亮），再短接C9A8，再插电源（指示灯亮），插上电源按开机几秒后电脑识别，松开短接，刷机。</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/C49A8.png" alt="C49A8"></p><h2 id="刷固件">刷固件</h2><p>线刷工具链接放在文后了</p><p>电脑上安装好刷机工具Amlogic USB Burning Tool 软件 →打开软件 →文件 →导入烧录包 →把【擦除flash】和【擦除bootloader】两项勾选先默认去掉</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E8%BD%AF%E4%BB%B6%E7%95%8C%E9%9D%A2.png" alt="软件界面"></p><p>等待刷完即可</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E5%88%B7%E5%9B%BA%E4%BB%B6%E4%B8%AD.png" alt="刷固件中"></p><p>刷完重启，成功后插个 HDMI 可以进桌面了</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E5%BD%93%E8%B4%9D%E6%A1%8C%E9%9D%A2.png" alt="当贝桌面"></p><p>设置密码为10000</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.png" alt="设置密码"></p><p>还有绿联私有云APP，正好下载登录了哈哈哈<img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E7%BB%BF%E8%81%94%E7%94%B5%E8%A7%86%E5%A2%99.jpg" alt="绿联电视墙"></p><p>忙活半天，我这10年的老电视不支持4K，尼玛</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E6%97%A0%E8%AF%AD%E4%BA%86.jpg" alt="无语了"></p><h1>工具以及固件下载链接</h1><ul><li><a href="https://www.ilanzou.com/s/YA2QZXV?code=nice">USB_Burning_Tool</a></li><li><a href="https://www.ilanzou.com/s/lNbQZkW?code=nice">中兴B860AV2.1-T固件</a></li></ul><h1>遇到的问题</h1><p>线刷的时候卡在1%，我这边是因为固件版本不对，后来更换 了版本之后正常刷取</p><p><img src="/2024/07/01/%E7%94%B5%E4%BF%A1%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E4%B8%AD%E5%85%B4B860AV2-1-T-%E5%88%B7%E5%9B%BA%E4%BB%B6%E5%8F%98%E5%BD%93%E8%B4%9D%E7%9B%92%E5%AD%90/%E8%AF%BB%E5%8F%96%E9%95%9C%E5%83%8F%E5%A4%B1%E8%B4%A5.png" alt="读取镜像失败"></p><h1>参考资料：</h1><ul><li><em><a href="https://www.znds.com/tv-1192319-1-1.html">新版本硬件B860AV2.1-A-T-M-B 短接示意图</a></em></li><li><em><a href="https://www.znds.com/tv-1131488-1-1.html">[分享] 一帖教你玩转B860AV2.1-A，免费固件下载，短接线刷，TTL接法等</a></em></li><li><em><a href="https://www.znds.com/tv-1191513-1-1.html">嘉乐数码中兴B860AV2.1-T非高安 /高安版本通用线刷固件当贝.</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>有趣的折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电视盒子</tag>
      
      <tag>当贝</tag>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C的爱恨情仇</title>
    <link href="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/"/>
    <url>/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/</url>
    
    <content type="html"><![CDATA[<h1>开篇</h1><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/I2C.png" alt="I2C"><br>上次写了 I2C 发包与测试后，决定细讲一下 I2C 协议，也作为自己的一个笔记，以后有些东西忘记了常来翻翻。</p><p>这是百度百科的介绍</p><div class="note note-info">            <p>I2C 总线是由 Philips 公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。<br>主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p>          </div><p>通过介绍来看，我们知道 I2C 是个在电子领域非常常用的一种协议，一个主机下可以挂多个从机。因为他的电路非常简单，设计也很巧妙，只需要两根线就可以实现，不需要特殊的接口电路，总结就是在简化布线、降低成本的同时也有很好的稳定性。</p><h2 id="5种速率">5种速率</h2><p>I2C 的五种工作模式如下所示，最常用得到的就是100K的了</p><ul><li>标准模式(Standard)：100 kbps</li><li>快速模式(Fast)：400 kbps</li><li>快速模式+(Fast-Plus)：1 Mbps</li><li>高速模式(High-speed)：3.4 Mbps</li><li>超快模式(Ultra-Fast)：5 Mbps（单向传输）</li></ul><hr><p>介绍完之后，下面进入正题，我也不知道会分几步来说，想到哪说到哪把，以下的资料都是在 IIC 协会手册（<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">IIC 手册</a>）上的加上自己的理解，有部分我自己也模模糊糊，发出来一起学习把，有错误帮忙指出下各位看官老少爷们~~</p><h1>一、时序</h1><h2 id="时序及特性">时序及特性</h2><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/timming.png" alt="I2C时序图"></p><p>如图为网上找的 IIC 时序图，这张图还是比较全面的。</p><p>结合 IIC 手册直接总结经验</p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/%E5%BC%80%E5%A7%8B%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97.png" alt="开始结束标志"></p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/%E8%AF%BB%E5%86%99%E4%BD%8D.png" alt="读写位"></p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/%E6%95%B0%E6%8D%AE%E6%9C%89%E6%95%88%E6%80%A7.png" alt="数据有效性"></p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/ACK&amp;NACK.png" alt="ACK&amp;NACK"></p><div class="note note-info">            <p><strong>起始信号：</strong> I2C 协议规定，SCL处于高电平时，SDA 由高到低变化，这种信号是起始信号<br><strong>停止信号：</strong> I2C 协议规定，SCL处于高电平，SDA 由低到高变化，这种信号是停止信号<br><strong>读写信号：</strong> I2C 协议规定，当第 8 个始终周期的时候，SDA 为高电平时为读（1）；SDA 为低电平时为写（0）<br><strong>数据有效性：</strong> I2C 协议对数据的采样发生在 SCL 高电平期间，除了起始和停止信号，在数据传输期间，SCL 为高电平时，SDA 必须保持稳定，不允许改变，在 SCL 低电平时才可以进行变化，即时钟高电平采样<br><strong>ACK/NACK信号：</strong> 在第 9 个时钟周期的时候，如果读取到 SDA 为低电平，则说明数据被从机成功接收到，可进行下一步操作。若 SDA 为高电平，说明数据未被应答，没有成功的建立通信，需进一步寻找原因</p>          </div><p>在这几点的基础上再来看这张图就很清晰明了了。<br>由此我们可以读出地址、读写情况、数据等信息。</p><hr><p>上面有说到 IIC 是可以进行一个主机和多个从机进行收发数据的，在单主设备中，不需要时钟同步和仲裁。而在多设备时，多个主设备可以同时在空闲的总线上开始发送数据，这时就需要仲裁决定哪一个来控制总线并完成它的数据传输，有时候也需要时钟同步来协同设备间的工作。而这正是通过时钟同步和仲裁来完成的。</p><h2 id="时钟同步">时钟同步</h2><p>有的时候，主机的速度快于从机的速度，或者从机需要处理其他事情而不能及时地从主机接收数据或者向主机发送数据。如果从设备希望主设备降低传输速率，可以通过将 SCL 主动拉低，延长 SCL 低电平时间的方法来通知主设备。当主设备下一次传输时发现SCL电平被拉低时，就进入等待，直到从设备完成操作并释放 SCL 线。这就要使用时钟同步来完成。</p><div class="note note-info">            <p><strong>时钟同步是通过连接到 SCL 总线的 I2C 接口 <em>“线与”</em> （全一为一，有零为零）实现。</strong></p><p><strong>SCL线上的低电平时间是由时钟低电平最长的器件决定，SCL 的高电平则是由高电平时间最短的期间决定。</strong></p><p><strong>时钟同步解决了 I2C 总线设备间的速度同步。</strong></p>          </div><blockquote><p>时钟同步的过程：</p><p>一旦主设备1的时钟拉低，就会把 SCL 总线拉低。当 SCL 总线从高拉低时，主设备将计数主设备时钟的低电位周期。<br>主设备2 检测到 SCL 线为低，也会立刻将 CLK1 拉低，不会等到 CLK1 的正常周期才拉低。<br>如果此时另外一个主设备的时钟仍然是低电平的，此时 SCL 总线也同样的保持为低。在此期间，低周期比较短的主设备1 将进入高电平状态等待。如图，主设备1 提前进入高电平等待，主设备2 继续保持低电平。<br>当所有主设备的时钟都为高电平时，将会把 SCL 线拉高。也就是说时钟低电平周期较长的主设备2 决定了 SCL 线为低的周期长度。<br>所有的主设备时钟都拉高时，将对他们的高电平时钟计数，第一个结束时钟高电平周期的主设备将会把 SCL 线拉低。主设备2 将 SCL 拉低后，主设备1 检测到 SCL 线为低时，CLK1 也立刻拉低。</p></blockquote><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5.png" alt="时钟同步"></p><h2 id="总线仲裁">总线仲裁</h2><p>仲裁和同步是一样的，只有在系统使用多个主设备时才需要，而从设备（slave）不参与仲裁程序。当然，只有在主线空闲的情况下，主设备才可以发起传输。两个主机可以在启动条件的最小保持时间内生成一个启动条件，从而在总线上生成一个有效的传输启动条件，然后仲裁程序决定哪一个主设备可以完成它的传输。</p><p>谁先在 SDA 线上发送低电平，谁就掌握对总线的控制权。<br>由于 I²C 总线的控制只由地址或主机码以及竞争主机发送的数据决定，没有中央主机，总线也没有任何定制的优先权。</p><p>必须特别注意的是：在串行传输时，当重复起始条件或停止条件发送到I²C 总线的时侯，仲裁过程仍在进行。如果可能产生这样的情况，有关的主机必须在帧格式相同位置发送这个重复起始条件或停止条件。也就是说，仲裁在不能下面情况之间进行：</p><ul><li><strong>重复起始条件和数据位</strong></li><li><strong>停止条件和数据位</strong></li><li><strong>重复起始条件和停止条件</strong></li></ul><blockquote><p>仲裁的过程：</p><p>当两个 master 对同一个地址的 slave 进行传输时，多个 master 会都进入数据周期，仲裁会单比特对单比特进行比较。在 SCL 为高的每一个比特位期间，每个主设备检查 SDA 线的电平是否与它所发送的相匹配。这个过程很可能需要比对很多位。如果传输的数据时完全相同的，则这个主设备可以完成地发送整个事务。<br>当主设备发送的比特位与 SDA 线不匹配时，例如图中 DATA1 在 SCL 线的第三个周期，此时 DATA1 拉高，而 DATA2 为低，DATA1 和 DATA2 在“线与”后 SDA 为低，匹配不成功。当主设备1 检测到一个与自身不相符的低电平，这时会关闭主设备1 的 SDA 传输驱动，另一个主设备2 会继续完成传输。</p></blockquote><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81.png" alt="总线仲裁"></p><p>根据上面的描述得出：</p><ul><li><strong>对于整个仲裁过程主控器1和主控器2都不会丢失数据；</strong></li><li><strong>各个主控器没有对总线实施控制的优先级别；</strong></li><li><strong>总线控制随即而定，他们遵循“低电平优先”的原则，即谁先发送低电平谁就会掌握对总线的控制权。</strong><br>“时钟同步”与“总线仲裁”可以总结如下规律：<br><strong>主控器通过检测SCL上的电平来调节与从器件的速度同步问题——时钟同步；</strong><br><strong>主控器通过检测SDA上自身发送的电平来判断是否发生总线“冲突”——总线仲裁。因此，I2C总线的“时钟同步”与“总线仲裁”是靠器件自身接口的特殊结构得以实现的。</strong></li></ul><h1>二、地址</h1><h2 id="保留地址">保留地址</h2><p>下表为 I2C 规范保留的两组 <code>1111XXX</code> 和 <code>0000XXX</code> 和 8 个地址。这些地址用于特殊用途。</p><table><thead><tr><th style="text-align:center">从机地址</th><th style="text-align:center">R/W</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0000 000</td><td style="text-align:center">0</td><td style="text-align:center">呼叫地址</td></tr><tr><td style="text-align:center">0000 000</td><td style="text-align:center">1</td><td style="text-align:center">起始字节</td></tr><tr><td style="text-align:center">0000 001</td><td style="text-align:center">X</td><td style="text-align:center">CBUS地址</td></tr><tr><td style="text-align:center">0000 010</td><td style="text-align:center">X</td><td style="text-align:center">保留供不同的总线格式</td></tr><tr><td style="text-align:center">0000 011</td><td style="text-align:center">X</td><td style="text-align:center">保留将来用</td></tr><tr><td style="text-align:center">0000 11X</td><td style="text-align:center">X</td><td style="text-align:center">HS模式主机码</td></tr><tr><td style="text-align:center">1111 0XX</td><td style="text-align:center">X</td><td style="text-align:center">10位从机地址</td></tr><tr><td style="text-align:center">1111 1XX</td><td style="text-align:center">X</td><td style="text-align:center">保留将来用</td></tr><tr><td style="text-align:center">X = don’t care; 1 = HIGH; 0 = LOW</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>IIC 地址也分为 8 位地址(加上第八位读写位)或 7 位地址（不加读写位），如上表格所示，有的 IIC 器件也支持 10 位地址的。<br>下面为手册上的 10 位地址的读写操作</p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/10%E4%BD%8D%E5%9C%B0%E5%9D%80%E5%86%99%E6%93%8D%E4%BD%9C.png" alt="10位地址写操作.png"></p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/10%E4%BD%8D%E5%9C%B0%E5%9D%80%E8%AF%BB%E6%93%8D%E4%BD%9C.png" alt="10位地址读操作"></p><p>I2C 总线的 10 bit 寻址和 7 bit 寻址是兼容的，这样就可以在同一个总线上同时使用 7 bit 地址和 10 bit 地址模式的设备，在进行 10 bit 地址传输时，第一字节是一个特殊的保留地址来指示当前传输的是 10 bit 地址</p><h1>三、电路</h1><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/%E6%BC%8F%E6%9E%81%E5%BC%80%E8%B7%AF.png" alt="漏极开路"></p><p>每一个IIC总线器件内部的SDA、SCL引脚电路结构都是一样的，引脚的输出驱动与输入缓冲连在一起。其中输出为漏极开路的场效应管、输入缓冲为一只高输入阻抗的同相器。</p><p>这种电路具有两个特点：</p><p><em><strong>1. 由于SDA、SCL为漏极开路结构，借助于外部的上拉电阻实现了信号的“线与”逻辑；</strong></em><br><em><strong>2. 引脚在输出信号的同时还将引脚上的电平进行检测，检测是否与刚才输出一致。为 “时钟同步”和“总线仲裁”提供硬件基础。</strong></em></p><p>那为什么 I2C 要用到漏极开路和上拉电阻呢？</p><blockquote><p>IIC协议支持多个主设备与多个从设备在一条总线上, 如果不用开漏输出, 而用推挽输出, 会出现主设备之间短路的情况. 至于为什么需要上拉电阻, 那是因为IIC通信需要输出高电平的能力.</p></blockquote><h1>四、Spec介绍</h1><p>下面是测试人员最需要关注的一页了，<strong>Electrical specifications and timing</strong></p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/Spec.png" alt="Spec"><br><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/timming.png" alt="timing"></p><p>对上面部分参数的解释如下</p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/VIH&amp;VIL.png" alt="VIH&amp;VIL"></p><p>VIH/VIL的解释：</p><blockquote><p>输入电平若在 VIL（max）~0之间，即输入电平为低电平</p><p>输入电平若在 VIH（min）~VDD之间，即输入电平为高电平</p></blockquote><p>VIL（max）为低电平的门限电平；VIH（min）为高电平的门限电平</p><p><img src="/2024/06/30/I2C%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/%E5%BB%BA%E7%AB%8B%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4.png" alt="建立保持时间"></p><p>建立保持时间的解释：</p><blockquote><p>建立时间（Tsu）： 在时钟采样沿之前，数据必须保持稳定的最短时间。</p><p>保持时间（Th）： 在时钟采样沿之后，数据必须保持稳定的最短时间。</p></blockquote><hr><p>暂时先写到这里吧，感觉写着写着就停不下来了，有好多东西都能无限的扩展，说多了就烦了，再加上水平技术也有限，暂时就这些吧。</p><p>参考 IIC 电气手册，部分资料来自baidu CSDN 博客园等个各大佬</p>]]></content>
    
    
    <categories>
      
      <category>信号完整性</category>
      
      <category>低速信号</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I2C</tag>
      
      <tag>信号测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青龙面板拉库失败——out of memory错误</title>
    <link href="/2024/06/29/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%8B%89%E5%BA%93%E5%A4%B1%E8%B4%A5%E2%80%94%E2%80%94out-of-memory%E9%94%99%E8%AF%AF/"/>
    <url>/2024/06/29/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%8B%89%E5%BA%93%E5%A4%B1%E8%B4%A5%E2%80%94%E2%80%94out-of-memory%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>青龙面板拉库的时候遇到一个问题，刚开始以为是代理问题，遂自己从 cloudfare 建个加速站，但是还是不行，从网上也找了很多加速代理，都没能成功拉下来。<br>然后想着不然直接【<strong>曲线救国</strong>】吧，就不用 github 拉了，直接 clone 到 gitee 上面拉<br>结果。。。<br>报了如下的错误</p><pre><code class="hljs">开始拉取仓库 mrabit_aliyundriveDailyCheck 到 /ql/data/repo/mrabit_aliyundriveDailyCheckCloning into '/ql/data/repo/mrabit_aliyundriveDailyCheck'...fatal: Out of memory, malloc failed (tried to allocate 524288000 bytes)fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.拉取 mrabit_aliyundriveDailyCheck 失败，请检查网络...</code></pre><p>目前还是不清楚啥原因</p><hr><p>用了这个代码之后貌似可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">git config --global --unset http.postbuffer<br></code></pre></td></tr></table></figure><p>好像是因为内存限制的原因。然后就在终端用了这个命令，不再报错了。</p><hr><p>关于 <code>http.postbuffer</code>的问题</p><blockquote><ul><li>将其提高到默认值以上可能会增加较大推送的延迟（因为客户端会将 HTTP 请求缓冲为较大的区块）。</li><li>如果将其设置为大于 HTTP 服务器的 HTTP 区块大小限制（例如 TFS 服务器的<code>web.config</code>中的<code>maxAllowedContentLength</code>和<code>maxRequestLength</code>），则大于区块大小限制的所有推送都将开始失败。</li></ul></blockquote><p>如果已经设置了<code>http.postbuffer</code>，怎么取消呢？<br>若要检查是否已设置，请运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">git config --show-origin --get-all http.postBuffer<br></code></pre></td></tr></table></figure><p>可能需要在全局 <code>.gitconfig</code> 文件中取消设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">git config --global --unset http.postBuffer<br></code></pre></td></tr></table></figure><p>以及在存储库级别 <code>.git/config</code>（替代全局设置）中取消设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">git config --local --unset http.postBuffer<br></code></pre></td></tr></table></figure><hr><p>当然，最后还是用了 Gitee 来进行拉库，正好 Gitee 可以自动 pull GitHub的仓库镜像。<br><img src="/2024/06/29/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%8B%89%E5%BA%93%E5%A4%B1%E8%B4%A5%E2%80%94%E2%80%94out-of-memory%E9%94%99%E8%AF%AF/pull_github.png" alt="pull_github"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>有趣的折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>青龙面板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux不执行shell脚本的可能的原因——换行符</title>
    <link href="/2024/06/25/Linux%E4%B8%8D%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0-%E6%8D%A2%E8%A1%8C%E7%AC%A6/"/>
    <url>/2024/06/25/Linux%E4%B8%8D%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0-%E6%8D%A2%E8%A1%8C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>今天在开发中遇到了 shell 脚本没法执行的情况，报错如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-bash: ./xxx.sh: /bin/bash^M: bad interpreter: No such file or directory<br></code></pre></td></tr></table></figure><p>经过排查，最终确认是 shell 脚本在 windows 上开发，使用 windows 的换行符 CRLF 导致的，换用 linux 的换行符 LF 之后可以正常使用。<br>原因是 .sh 默认是按照 Windows 下的 CRLF 做回车换行的，这个在 linux 下执行就会报错，要把回车换行改成 LF</p><p>在进行转换的时候使用了notepad++的替换功能。</p><p><img src="/2024/06/25/Linux%E4%B8%8D%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0-%E6%8D%A2%E8%A1%8C%E7%AC%A6/notepad%E6%9B%BF%E6%8D%A2.png" alt="notepad替换"></p><p>或者在右下角进行更改</p><p><img src="/2024/06/25/Linux%E4%B8%8D%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0-%E6%8D%A2%E8%A1%8C%E7%AC%A6/%E8%BD%ACUnix.png" alt="转Unix"></p><p>或者在Linux终端下直接用下面的命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;s/\r$//&#x27;</span> xx.sh<br></code></pre></td></tr></table></figure><h2 id="原理解释">原理解释:</h2><p>1). Windows下换行符号是<code>“\r\n”</code><br>回车符是 Carriage Return, C语言中是<code>\r</code>；换行符是 Line Feed, C语言中是<code>\n</code>；回车换行符实际是两个字符, 就是<code>\r\n</code>;<br>而 linux 下是<code>\n</code>没有<code>\r</code>，所以直接把/r去掉就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>搬砖日记</category>
      
      <category>系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>疑难杂症</tag>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C发包与测试</title>
    <link href="/2024/01/04/I2C%E5%8F%91%E5%8C%85%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/01/04/I2C%E5%8F%91%E5%8C%85%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>今天测试 I2C ，又被 B 哥上了一课，<s>灰常尴尬了属于是</s> 好久都没测试了，手太生了。。。还是需要温故而知新啊。</p><h2 id="正题">正题</h2><p>没那么多的前戏了，直接进入吧，<s>干干涩涩你忍着点</s><br>这次测试的是 BUS 3 --&gt; I2C_TEMP_SEN1_SDA，应该是 BMC 到 CPU 那边的一颗温度 IC 吧</p><p><img src="/2024/01/04/I2C%E5%8F%91%E5%8C%85%E4%B8%8E%E6%B5%8B%E8%AF%95/Master.png" alt="Master"></p><p><img src="/2024/01/04/I2C%E5%8F%91%E5%8C%85%E4%B8%8E%E6%B5%8B%E8%AF%95/Slave.png" alt="Slave"></p><p>示波器上抓了很久找到了波形，但是呢，也没有相应的数据，想起来需要发包。于是登录 BMC 串口准备进行发包<br>发包有俩好处：</p><ol><li>如果没有数据输出可以自定义数据输出，不至于卡波形卡在地址位</li><li>可以直接输出想要的波形，不用等到系统跑到这个BUS</li></ol><p><img src="/2024/01/04/I2C%E5%8F%91%E5%8C%85%E4%B8%8E%E6%B5%8B%E8%AF%95/BMC%E4%B8%B2%E5%8F%A3.png" alt="BMC串口"></p><p>在这里发包用的是<code>i2cget</code>，发包指令为<code>i2cget -f -y 2 0x48 0x01</code>，当然，最后一个<code>0x01</code>是自己编的，可以随便替换，比如后面我又换成<code>0x48</code>了。<br>其中里面参数 2 是代表了 BUS，等等，为毛是 BUS 2，线路图上不是 SDA 3 吗？因为在发包时<code>i2cget</code>计算 BUS 是从 0 开始的。<br>可以看到，原本的地址为<code>0x90</code>，这是8位地址，在<code>i2cget</code>中需要转换成7位地址。so easy，直接除以2，算出来是<code>0x48</code>。<br>桥豆嘛嘚，怎么就<code>0x48</code>了？请自行百度~<br><code>i2cget</code>tool 的具体的参数解释如下：</p><table><thead><tr><th style="text-align:center">flag</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">-V</td><td style="text-align:center">显示当前的版本并退出</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:center">强制访问设备，即使它已经繁忙。默认情况下，i2cget 将拒绝访问已经在内核驱动程序控制下的设备。用这个flag可能比较危险，它可能会严重混淆有问题的内核驱动程序。它还可能导致 i2cget 返回无效值。因此，只有在您知道自己在做什么的情况下，才使用风险自负。</td></tr><tr><td style="text-align:center">-y</td><td style="text-align:center">禁用交互模式。默认情况下，i2cget 将等待用户的确认，然后再处理 I2C 总线。使用此标志时，它将直接执行操作。这主要用于脚本。请谨慎使用</td></tr><tr><td style="text-align:center">-a</td><td style="text-align:center">允许在 0x00 - 0x07 和 0x78 - 0x7f 之间使用地址。不推荐。i2cget 有两个必需的选项。i2cbus 表示要扫描的 I2C 总线的编号或名称。此编号应对应于 i2cdetect -l 列出的总线之一。chip-address 指定该总线上芯片的地址，是介于 0x08 和 0x77 之间的整数。data-address 指定该芯片上要读取的地址，并且是介于 0x00 和 0xFF 之间的整数。如果省略，将读取当前活动的寄存器（如果这对所考虑的芯片有意义）。mode 参数（如果指定）是字母 b、w 或 c 之一，分别对应于读字节数据、读字数据或写字节/读字节事务。还可以将 p 附加到 mode 参数以启用 PEC。如果省略 mode 参数，则 i2cget 默认为读字节数据事务，除非 data-address 也被省略，在这种情况下，默认（且唯一有效）事务是单个读取字节。</td></tr></tbody></table><p>没错，生搬硬套，翻译的~<br>发包之后，对应的波形就出来了，也有相应我发的数据了。波形后面再补吧</p><hr><p>补：能看出地址和数据的波形找不到了，随便换张图意思意思吧。</p><p><img src="/2024/01/04/I2C%E5%8F%91%E5%8C%85%E4%B8%8E%E6%B5%8B%E8%AF%95/I2C_Adress.jpg" alt="I2C_Adress"></p><blockquote><p>通过这张图很明显的可以看出七位地址了，在<code>CLK</code>高电平的时候进行数据采样，地址就是<code>101 1000</code>，换算过来就是<code>0x58</code>啦。如果是 8 位地址的话就是<code>1011 0000</code>，换算过来就是<code>0xB0</code>不过这张图是用的地址采样，真爽啊，我测试的那台机器没有I2C地址采样，需要手动去发包去抓。</p></blockquote><h2 id="结语">结语</h2><p>实际上我想表达的意思就是需要多温故而知新，有些东西其实之前都掌握了，也很简单，但是长时间不去做了，可能就忘记了。</p>]]></content>
    
    
    <categories>
      
      <category>信号完整性</category>
      
      <category>低速信号</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I2C</tag>
      
      <tag>信号测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
